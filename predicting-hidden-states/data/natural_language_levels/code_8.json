{
  "level": "code",
  "user": "Generate Python code",
  "assistant": "from symbolic_music.parse_note_events import Score, NoteEvent\nimport fractions\nimport os.path\nimport glob\nimport numpy as np\nimport pickle\n\n\nclass NoteEventDataset:\n    def __init__(self, categories=list(NoteEvent._fields), offset_in_second=False):\n        # self.categorical_attributes = [('instrument', 0), ('offset', 1), ('offset_in_measure', 2),\n        #                                ('pitch', 3), ('velocity', 4), ('duration', 5)]\n        # self.categorical_dicts = {key[1]: {} for key in self.categorical_attributes}\n        self.category_lookups = [(category, i, {}) for i, category in enumerate(categories)]\n        self.reverse_lookups = []\n        self.offset_in_seconds = offset_in_second\n        self.data = {}\n\n    def discretize_event_list(self, event_list):\n        discretized_events = []\n        for event in event_list:\n            d_event = []\n            for _, attribute_index, category_dict in self.category_lookups:\n                value = event[attribute_index]\n                try:\n                    d = category_dict[value]\n                except KeyError:\n                    category_dict[value] = len(category_dict)\n                    d = category_dict[value]\n                d_event.append(d)\n            discretized_events.append(d_event)\n        return discretized_events\n\n    def process_files(self, path, filter=lambda s: True):\n        files = find_music_files(path)\n        for file in files:\n            score = Score(file)\n            if filter(score):\n                event_list = score.get_note_events(relative_offset=True, offset_in_seconds=self.offset_in_seconds)\n                discretized_events = self.discretize_event_list(event_list)\n                name = os.path.basename(file)\n                print(\"process\", name)\n                if name in self.data:\n                    raise(\"File\", name, \"already is in the dataset. Files may not share their basename\")\n                else:\n                    self.data[name] = np.array(discretized_events)\n        return self.data\n\n    def load(self, path):\n        with open(path, 'rb') as handle:\n            data_dict = pickle.load(handle)\n        self.data = data_dict['data']\n        self.category_lookups = data_dict['category_lookups']\n\n    def save(self, path):\n        data_dict = {'data': self.data, 'category_lookups': self.category_lookups}\n        with open(path, 'wb') as handle:\n            pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)\n\n    def calculate_reverse_lookups(self):\n        self.reverse_lookups = []\n        for name, i, lookup in self.category_lookups:\n            rev_lookup = {value: key for key, value in lookup.items()}\n            self.reverse_lookups.append((name, i, rev_lookup))\n\n    def change_lookups(self, category_numbers, new_keys):\n        new_lookups = {}\n        self.calculate_reverse_lookups()\n        for i, n in enumerate(category_numbers):\n            new_lookups[n] = {key: value for value, key in enumerate(new_keys[i])}\n            number, name, _ = self.category_lookups[n]\n            self.category_lookups[n] = (number, name, new_lookups[n])\n        for file, data in self.data.items():\n            print(\"process\", file)\n            for idx in range(data.shape[0]):\n                for n in category_numbers:\n                    value = self.reverse_lookups[n][2][data[idx, n]]\n                    data[idx, n] = new_lookups[n][value]\n            min_pitch = data[:, 3].min()\n            print(\"min pitch:\", min_pitch)\n\n\ndef find_music_files(path, types=['.xml', '.mxl', '.mid', '.midi']):\n    if not path.is_dir:\n        files = [path]\n    else:\n        files = []\n        for file_type in types:\n            files.extend(list(path.glob('**/*' + file_type)))\n            #files.extend(glob.glob(path + '/**/*' + file_type, recursive=True))\n    return files\n\n\nif __name__ == '__main__':\n    dataset = NoteEventDataset()\n\n    dataset.load('/home/hev7rng/data/bach_chorales/bach_chorales_note_events_2.p')\n    dataset.change_lookups([3], [list(range(128))])\n    dataset.calculate_reverse_lookups()\n    dataset.save('/home/hev7rng/data/bach_chorales/bach_chorales_note_events_pitched.p')\n\n    # def check_func(score):\n    #     if len(score.parts) != 4:\n    #         return False\n    #     if score.time_signatures != [(4, 4)]:\n    #         return False\n    #     return True\n    #\n    # dataset.process_files('/home/hev7rng/Software/music21/music21/corpus/bach/',\n    #                       check_func)\n\n    pass\n\n\n"
}