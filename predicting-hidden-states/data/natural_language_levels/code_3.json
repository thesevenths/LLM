{
  "level": "code",
  "user": "Generate Python code",
  "assistant": "import h5py\nimport pickle\nimport numpy as np\nfrom pathlib import Path\nimport random\nimport torch\n\nfrom symbolic_music.midi_to_commands import MidiDataset\n\nfiles_path = Path(\"C:/Users/HEV7RNG/Documents/data/MAESTRO/maestro-v1.0.0_wo_pedal/training\")\noutput_file_path = \"C:/Users/HEV7RNG/Documents/data/MAESTRO/maestro-v1.0.0_wo_pedal/maestro_training_tempo_augented.hdf5\"\n\ntempo_factors = [0.9, 0.95, 1., 1.05, 1.1]\n\nmidi_files = list(files_path.glob(\"**/*.mid\"))\nmidi_files += list(files_path.glob(\"**/*.midi\"))\n\noutput_file = h5py.File(output_file_path, 'w')\n\nfor tempo_factor in tempo_factors:\n    all_midi_files = []\n\n    for file in midi_files:\n        print(file)\n        dataset = MidiDataset(instrument_pitch_feature=False)\n\n        on_off_wait_commands = dataset.create_on_off_wait_commands(file, tempo_factor=tempo_factor)\n        num_additional_features = np.cumsum(dataset.additional_feature_sizes)[-1].item()\n\n        p = 1000  # save features roughly every p commands\n        wait_command_indices = torch.arange(0, on_off_wait_commands.shape[0])[on_off_wait_commands[:, 1] == 0]\n        d = wait_command_indices % p\n        wait_command_numbers_to_save = torch.arange(1, len(d))[d[:-1] - d[1:] > 0]\n        on_off_wait_command_snapshot_positions = wait_command_indices[wait_command_numbers_to_save]\n\n        # check if there are really only wait commands\n        on_off_wait_commands_at_save_positions = on_off_wait_commands[on_off_wait_command_snapshot_positions]\n        if on_off_wait_commands_at_save_positions[:, 1].sum() > 0:\n            raise Exception\n        on_off_wait_snapshot_values = on_off_wait_commands_at_save_positions[:, 2]\n\n        item_tensor = dataset.create_input_items(on_off_wait_commands)\n        features, commands = dataset.calculate_features(item_tensor)\n        feature_wait_command_indices = torch.arange(0, commands.shape[0])[commands < dataset.num_time_bins]\n        feature_indices_to_save = feature_wait_command_indices[wait_command_numbers_to_save]\n        feature_snapshots = features[feature_indices_to_save, :]\n\n        feature_snapshot_values = torch.argmax(feature_snapshots[:, :dataset.command_feature_offset[-1]], dim=1)\n        if ((on_off_wait_snapshot_values - feature_snapshot_values)**2).sum() > 0:\n            raise Exception\n\n        feature_snapshots = torch.cat([on_off_wait_command_snapshot_positions[:, None],\n                                       feature_snapshots[:, -num_additional_features:]], dim=1)\n        all_midi_files.append((file.name, on_off_wait_commands, feature_snapshots))\n\n    for name, features, snapshots in all_midi_files:\n        if tempo_factor != 1.:\n            name += '_tempo_' + str(tempo_factor)\n        print(name)\n        group = output_file.create_group(name)\n        group.attrs[\"instruments\"] = [b\"piano\"]\n\n        data = group.create_dataset(\"data\", data=features.numpy().astype(np.int32))\n        snapshots = group.create_dataset(\"snapshots\", data=snapshots.numpy().astype(np.int32))\n\noutput_file.close()"
}