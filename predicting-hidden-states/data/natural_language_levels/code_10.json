{
  "level": "code",
  "user": "Generate Python code",
  "assistant": "import mido\nfrom copy import copy\nimport os.path\nfrom pathlib import Path\nfrom collections import Set\n\nclass PianoNoteSustain:\n    def __init__(self, pedal_threshold=1):\n        self.pedal_threshold = pedal_threshold\n\n    def process_file(self, path, filename_addition='_wo_pedal'):\n        file = mido.MidiFile(path)\n        for track_number, track in enumerate(file.tracks):\n            new_track = mido.MidiTrack()\n            sustain = False\n            sustained_notes = set()\n            time_offset = 0\n            for msg in track:\n                #print(msg.time)\n                if msg.type == 'control_change':\n                    if msg.control == 64:\n                        if msg.value >= self.pedal_threshold:\n                            sustain = True\n                            time_offset += msg.time\n                        else:\n                            # unsustain\n                            if len(sustained_notes) == 0:\n                                time_offset += msg.time\n                            for i, note in enumerate(sustained_notes):\n                                time = time_offset + msg.time if i == 0 else 0\n                                note_off_msg = mido.Message('note_on', note=note, velocity=0, time=time,\n                                                            channel=msg.channel)\n                                new_track.append(note_off_msg)\n                                time_offset = 0\n                            sustained_notes = set()\n                            sustain = False\n                    else:\n                        msg.time = msg.time + time_offset\n                        new_track.append(msg)\n                        time_offset = 0\n                elif msg.type == 'note_on':\n                    if msg.velocity > 0:\n                        msg.time = msg.time + time_offset\n                        if sustain:\n                            # if a sustained note is repeated, turn it off first and remove it from sustained notes\n                            if msg.note in sustained_notes:\n                                sustained_notes.remove(msg.note)\n                                note_off_msg = copy(msg)\n                                note_off_msg.velocity = 0\n                                note_off_msg.time = msg.time\n                                new_track.append(note_off_msg)\n                                msg.time = 0\n                        new_track.append(msg)\n                        time_offset = 0\n                    else:\n                        if sustain:\n                            time_offset += msg.time\n                            sustained_notes.add(msg.note)\n                        else:\n                            msg.time + time_offset\n                            new_track.append(msg)\n                            time_offset = 0\n\n            file.tracks[track_number] = new_track\n        file.save(path.parent / (path.name.split('.mid')[0] + filename_addition + '.midi'))\n\nif __name__ == '__main__':\n    #path = Path('C:/Users/HEV7RNG/Documents/data/midi_examples/scriabin_etude.midi')\n    path =  Path('C:/Users/HEV7RNG/Documents/data/midi_examples/MIDI-Unprocessed_042_PIANO042_MID--AUDIO-split_07-06-17_Piano-e_1-02_wav--3.midi')\n    pns = PianoNoteSustain(pedal_threshold=1)\n    pns.process_file(path)\n    pass"
}