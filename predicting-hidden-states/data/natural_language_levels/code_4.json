{
  "level": "code",
  "user": "Generate Python code",
  "assistant": "import numpy as np\nimport mido\nfrom collections import namedtuple\n\nfrom symbolic_music.write_score import GeneratedScore\n\nItemTypes = namedtuple('ItemTypes', ['wait', 'instrument', 'velocity', 'pitch', 'end'])\n\n\nclass ItemContextualizer:\n    def __init__(self, num_instruments=4, num_pitches=128):\n        self.num_batches = 1\n        self.num_instrument = num_instruments\n        self.num_pitches = num_pitches\n        self.item_size = 6 + 2*self.num_pitches + 2*self.num_instrument\n\n        self.clear_context()\n\n        # item_type, item_value, offset, instrument, velocity, active_total_pitches, active_instrument_pitches (multi-hot), position, previous_pitches, previous_ends\n        self.item_split = [1, 2, 3, 4, 5,\n                           5+self.num_pitches,\n                           5+2*self.num_pitches,\n                           6+2*self.num_pitches,\n                           6+2*self.num_pitches+self.num_instrument]\n\n    def add_item(self, itype, value):\n        # with batch dimension\n        self.current_position += 1\n\n        is_wait = itype == 0\n        self.current_offset[is_wait] += value[is_wait]\n\n        is_instrument = itype == 1\n        self.current_instrument[is_instrument] = value[is_instrument]\n\n        is_velocity = itype == 2\n        self.current_velocity[is_velocity] = value[is_velocity]\n\n        is_pitch = itype == 3\n        self.current_active_total_pitches[is_pitch, value[is_pitch]] += 1\n        self.current_active_instrument_pitches[is_pitch, self.current_instrument, value[is_pitch]] = 1\n        self.current_previous_pitch[is_pitch, self.current_instrument] = self.current_position[is_pitch]\n\n        is_end = itype == 4\n        self.current_active_total_pitches[is_end, value[is_end]] -= 1\n        self.current_active_instrument_pitches[is_end, self.current_instrument, value[is_end]] = 0\n        self.current_previous_end[is_end, self.current_instrument] = self.current_position[is_end]\n\n        # contextualized item\n        n = np.newaxis\n        item = [itype[:, n], value[:, n],\n                self.current_offset[:, n], self.current_instrument[:, n], self.current_velocity[:, n],\n                self.current_active_total_pitches,\n                self.current_active_instrument_pitches[:, self.current_instrument, :][:, 0, :],\n                self.current_position[:, n], self.current_previous_pitch, self.current_previous_end]\n        item = np.concatenate(item, axis=1)\n        self.current_context = np.concatenate([self.current_context, item[:, np.newaxis]], axis=1)\n        return item\n\n    def clear_context(self):\n        self.current_context = np.zeros([self.num_batches, 0, self.item_size], dtype=np.long)\n\n        self.current_offset = np.zeros(self.num_batches, dtype=np.long)\n        self.current_instrument = np.zeros(self.num_batches, dtype=np.long)\n        self.current_velocity = np.zeros(self.num_batches, dtype=np.long)\n        self.current_active_total_pitches = np.zeros([self.num_batches, self.num_pitches], dtype=np.long)\n        self.current_active_instrument_pitches = np.zeros([self.num_batches, self.num_instrument, self.num_pitches],\n                                                          dtype=np.long)\n        self.current_position = np.zeros(self.num_batches, dtype=np.long) - 1\n        self.current_previous_pitch = np.zeros([self.num_batches, self.num_instrument], dtype=np.long) - 1\n        self.current_previous_end = np.zeros([self.num_batches, self.num_instrument], dtype=np.long) - 1\n\n\n    def write_score(self, instruments=None, offset_factor=0.01, max_duration=100., add_open_notes=True):\n        if instruments is None:\n            instruments = [str(i) for i in range(self.num_instrument)]\n\n        open_notes = {i: [] for i in instruments}\n        notes = {i: [] for i in instruments}\n\n        for item in self.current_context[0]:\n            item_type, item_value, offset, instrument, velocity, _, _, _, _, _ = np.split(item, self.item_split, axis=0)\n            current_instrument = instruments[instrument[0]]\n            if item_type[0] == 3:  # pitch\n                open_notes[current_instrument].append((instrument[0],\n                                                       offset[0] * offset_factor,\n                                                       item_value[0],\n                                                       velocity[0],\n                                                       1.))\n\n            if item_type[0] == 4:  # end\n                o_list = open_notes[instruments[instrument[0]]]\n                ended_note = next((n for n in o_list if n[2] == item_value[0]), None)\n\n                if ended_note is None:\n                    print('could not match end item', item)\n                    continue\n\n                o_list.remove(ended_note)\n                ended_note = list(ended_note)\n                duration = offset[0] * offset_factor - ended_note[1]\n                if duration <= max_duration and duration > 0.:\n                    ended_note[4] = duration\n                    notes[current_instrument].append(ended_note)\n\n        if add_open_notes:\n            for i in instruments:\n                notes[i].extend(open_notes[i])\n\n        score = GeneratedScore(instruments=instruments, lookups=None, time_signature='4/4', relative_offset=False)\n        for i in instruments:\n            for n in notes[i]:\n\n                score.add_note(instrument=instruments[n[0]], offset=n[1], pitch=n[2], velocity=n[3], duration=n[4])\n        return score\n\n    def write_midi(self, instruments=None):\n        file = mido.MidiFile()\n\n        if instruments is None:\n            instruments = [str(i) for i in range(self.num_instrument)]\n\n        tracks = mido.MidiTrack()\n\n        current_instrument = 0\n        current_velocity = 100\n\n\n\n\n\n\n\n"
}