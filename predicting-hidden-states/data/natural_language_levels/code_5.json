{
  "level": "code",
  "user": "Generate Python code",
  "assistant": "from symbolic_music.note_event_dataset import NoteEventDataset\nimport numpy as np\nimport pickle\nimport math\n\nmidi_note_names = {\n        0: 'C',\n        1: 'C#',\n        2: 'D',\n        3: 'Eb',\n        4: 'E',\n        5: 'F',\n        6: 'F#',\n        7: 'G',\n        8: 'G#',\n        9: 'A',\n        10: 'Bb',\n        11: 'B'}\n\n\ndef midi_to_name(midi):\n    note = midi_note_names[midi % 12]\n    octave = midi // 12 - 1\n    return note + str(octave)\n\n\nclass ItemizedNoteDataset:\n    def __init__(self, note_event_dataset=None, wait_dict={}, tempo=60):\n        self.data = {}\n        self.category_lookups = []\n        self.reverse_lookups = None\n        self.tempo = tempo\n        if note_event_dataset is not None:\n            self.itemize_dataset(note_event_dataset, wait_dict)\n        \n    def itemize_dataset(self, note_event_dataset, wait_dict={}):\n        max_wait = wait_dict[len(wait_dict)]\n        note_event_dataset.calculate_reverse_lookups()\n        self.data = {}\n        for file, data in note_event_dataset.data.items():\n            note_items = []\n            current_time = 0\n            for note in data:\n                current_time += note_event_dataset.reverse_lookups[1][2][note[1]]\n                duration = note_event_dataset.reverse_lookups[5][2][note[5]]\n                note_items.append([current_time, note[0], note[4], note[3], note[2]]) # note on event: time, instrument, velocity, pitch, offset_in_measure\n                note_items.append([current_time + duration, note[0], note[3], note[2]]) # note off event: time, instrument, pitch, offset_in_measure\n\n            note_items.sort(key=lambda e: e[1])\n            note_items.sort(key=lambda e: e[0])\n            \n            compressed_items = []\n            current_time = 0    \n            current_instrument = None\n            current_velocity = None \n            for item in note_items:\n                item_time = item[0]\n                if item_time != current_time:\n                    wait = int((item_time - current_time) * (100 * 60 / self.tempo)) # wait in 0,01 s steps\n                    while wait > max_wait:\n                        compressed_items.append([0, max_wait, item[-1]])\n                        wait -= max_wait\n                    compressed_items.append([0, wait, item[-1]])\n                    current_time = item_time\n\n\n                item_instrument = item[1]\n                if item_instrument != current_instrument:\n                    compressed_items.append([1, item_instrument, item[-1]])\n                    current_instrument = item_instrument\n\n                if len(item) == 5:  # note on event\n                    item_velocity = item[2]\n                    if item_velocity != current_velocity:\n                        compressed_items.append([2, item_velocity, item[-1]])\n                        current_velocity = item_velocity\n\n                    item_pitch = item[3]\n                    compressed_items.append([3, item_pitch, item[-1]])\n                else:  # note off event\n                    item_pitch = item[2]\n                    compressed_items.append([4, item_pitch, item[-1]])\n\n            self.data[file] = np.int64(compressed_items)\n        self.category_lookups = [('wait', 0, wait_dict),\n                                 ('instrument', 1, note_event_dataset.category_lookups[0][2]),\n                                 ('velocity', 2, note_event_dataset.category_lookups[4][2]),\n                                 ('pitch', 3, note_event_dataset.category_lookups[3][2]),\n                                 ('note_end', 4, note_event_dataset.category_lookups[3][2]),\n                                 ('offset_in_measure', 5, note_event_dataset.category_lookups[2][2])]\n        \n    def calculate_reverse_lookups(self):\n        self.reverse_lookups = []\n        for name, i, lookup in self.category_lookups:\n            rev_lookup = {value: key for key, value in lookup.items()}\n            self.reverse_lookups.append((name, i, rev_lookup))\n            \n    def load(self, path):\n        with open(path, 'rb') as handle:\n            data_dict = pickle.load(handle)\n        self.data = data_dict['data']\n        self.category_lookups = data_dict['category_lookups']\n        self.calculate_reverse_lookups()\n\n    def save(self, path):\n        data_dict = {'data': self.data, 'category_lookups': self.category_lookups}\n        with open(path, 'wb') as handle:\n            pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)\n            \n    def string_representation(self, data, show_offset_in_measure=False):\n        string_data = ''\n        if self.reverse_lookups is None:\n            self.calculate_reverse_lookups()\n        for event in data:\n            event_type = event[0]\n            lookup = self.reverse_lookups[event_type]\n            if event_type == 3:\n                name = 'play'\n            elif event_type == 4:\n                name = 'end'\n            else:\n                name = lookup[0]\n                \n            string_data += name \n                \n            value = lookup[2][event[1]]\n            if event_type == 3 or event_type == 4:\n                value = midi_to_name(value)\n                \n            string_data += ' ' + str(value)\n            \n            if show_offset_in_measure:\n                offset = self.reverse_lookups[5][2][event[2]]\n                string_data += ' ' + str(offset)\n                \n            string_data += ', '\n        return string_data\n                \n\nif __name__ == '__main__':\n    dataset = NoteEventDataset()\n    dataset.load('C:/Users/HEV7RNG/Documents/data/bach_chorales/bach_chorales_note_events_training.p')\n\n    itemized_dataset = ItemizedNoteDataset(dataset)\n    itemized_dataset.calculate_reverse_lookups()\n    itemized_dataset.save('C:/Users/HEV7RNG/Documents/data/bach_chorales/bach_chorales_notes_itemized_training.p')\n    \n    eval_dataset = NoteEventDataset()\n    eval_dataset.load('C:/Users/HEV7RNG/Documents/data/bach_chorales/bach_chorales_note_events_validation.p')\n\n    eval_itemized_dataset = ItemizedNoteDataset(eval_dataset,\n                                                wait_dict=itemized_dataset.category_lookups[0][2])\n    eval_itemized_dataset.calculate_reverse_lookups()\n    eval_itemized_dataset.save('C:/Users/HEV7RNG/Documents/data/bach_chorales/bach_chorales_notes_itemized_validation.p')\n    \n    "
}